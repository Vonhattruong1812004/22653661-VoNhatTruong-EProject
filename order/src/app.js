// app.js
require('dotenv').config();
const express = require("express");
const mongoose = require("mongoose");
const amqp = require("amqplib");
const Order = require("./models/order");
const config = require("./config");

class App {
    constructor() {
        this.app = express();
        this.connectDB();
        this.setupOrderConsumer();
    }

    async connectDB() {
        try {
            await mongoose.connect(config.mongoURI, {
                useNewUrlParser: true,
                useUnifiedTopology: true,
            });
            console.log("‚úÖ MongoDB connected");
        } catch (err) {
            console.error("‚ùå MongoDB connection error:", err.message);
            process.exit(1);
        }
    }

    async disconnectDB() {
        await mongoose.disconnect();
        console.log("MongoDB disconnected");
    }

    async setupOrderConsumer() {
        console.log("üîó Connecting to RabbitMQ...");

        const MAX_ATTEMPTS = 5;
        const RETRY_DELAY = 5000;
        let attempt = 0;

        while (attempt < MAX_ATTEMPTS) {
            attempt++;
            try {
                // K·∫øt n·ªëi RabbitMQ v·ªõi frameMax v√† heartbeat
                const connection = await amqp.connect(config.rabbitMQURI, {
                    frameMax: 131072,
                    heartbeat: 10,
                });
                const channel = await connection.createChannel();

                // T·∫°o queue t·ª´ config
                await channel.assertQueue(config.rabbitMQQueue);
                console.log(`‚úÖ Connected to RabbitMQ and queue '${config.rabbitMQQueue}' is ready`);

                // Consume messages
                channel.consume(config.rabbitMQQueue, async(msg) => {
                    if (!msg) return;

                    console.log("üì• Consuming ORDER message");
                    const { products, username, orderId } = JSON.parse(msg.content.toString());

                    const newOrder = new Order({
                        products,
                        user: username,
                        totalPrice: products.reduce((acc, product) => acc + product.price, 0),
                    });

                    await newOrder.save();
                    channel.ack(msg);
                    console.log("‚úÖ Order saved to DB and ACK sent to queue");

                    // Send fulfilled order to PRODUCTS queue (t√™n queue c√≥ th·ªÉ config th√™m n·∫øu c·∫ßn)
                    const { user, products: savedProducts, totalPrice } = newOrder.toJSON();
                    const productsQueue = "products"; // ho·∫∑c config.productsQueue
                    channel.sendToQueue(
                        productsQueue,
                        Buffer.from(JSON.stringify({ orderId, user, products: savedProducts, totalPrice }))
                    );
                    console.log(`‚û°Ô∏è Message sent to '${productsQueue}' queue`);
                });

                break; // exit loop khi connect th√†nh c√¥ng
            } catch (err) {
                console.error(`‚ùå Attempt ${attempt} failed: ${err.message}`);
                if (attempt < MAX_ATTEMPTS) {
                    console.log(`‚è≥ Retrying in ${RETRY_DELAY / 1000}s...`);
                    await new Promise(r => setTimeout(r, RETRY_DELAY));
                } else {
                    console.error("‚ùå Failed to connect to RabbitMQ after maximum attempts");
                    process.exit(1);
                }
            }
        }
    }

    start() {
        this.server = this.app.listen(config.port, () =>
            console.log(`üöÄ Server started on port ${config.port}`)
        );
    }

    async stop() {
        await this.disconnectDB();
        if (this.server) this.server.close();
        console.log("üõë Server stopped");
    }
}

module.exports = App;